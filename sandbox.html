<!DOCTYPE html>
<html>
  <body>
    <script src="./script/p5.js"></script>
    <script>
      // 2D Perlin Noise Implementation
      function normalizePixels(pixelArray) {
        const result = new Uint8ClampedArray(pixelArray.length * 4);
        let resultIdx = 0;
        for (let i = 0; i < pixelArray.length; i++) {
          const pixel = pixelArray[i];
          result[resultIdx++] = Math.round(pixel.r * 255);
          result[resultIdx++] = Math.round(pixel.g * 255);
          result[resultIdx++] = Math.round(pixel.b * 255);
          result[resultIdx++] = 255;
        }
        return result;
      }
      // Process incoming messages
      window.addEventListener("message", (event) => {
        let result;
        // EARLY RETURNS
        // Only accept messages from our parent
        if (event.source !== window.parent) {
          return;
        }
        if (!event.data) {
          return;
        }
        if (typeof event.data !== "object") {
          return;
        }

        try {
          

          // New format with code and worldSize
          const { userInput, worldSize } = event.data;

          // Create a minimal p5 instance just for noise functions
          const p5Instance = new p5(function (p) {
            p.setup = function () {
              // Minimal setup - we just need the noise functions
              p.noiseSeed(12345);
              p.noCanvas();
            };
          });

          // Override potentially blocking APIs to prevent freezing
          const originalAlert = window.alert;
          const originalConsole = window.console;
          window.alert = () => {}; // Disable alerts
          window.console = {
            log: () => {},
            error: () => {},
            warn: () => {},
            info: () => {}
          };

          // Create shared math and query objects outside the function to avoid recreating them per pixel
          const math = {
            abs: Math.abs,
            sin: Math.sin,
            cos: Math.cos,
            clamp: (value, min, max) => Math.max(min, Math.min(max, value)),
            ceil: Math.ceil,
            floor: Math.floor,
            trunc: Math.trunc,
            round: Math.round,
            mod: (value, denominator) => value % denominator,
            pow: Math.pow,
            sqrt: Math.sqrt,
            exp: Math.exp,
            pi: Math.PI,
            max: Math.max,
            min: Math.min,
            min_angle: (value) => {
              let angle = value % (2 * Math.PI);
              if (angle > Math.PI) angle -= 2 * Math.PI;
              if (angle < -Math.PI) angle += 2 * Math.PI;
              return angle;
            },
            asin: Math.asin,
            acos: Math.acos,
            atan: Math.atan,
            atan2: Math.atan2,
            random: (low, high) => Math.random() * (high - low) + low,
            random_integer: (low, high) => Math.floor(Math.random() * (high - low + 1)) + low,
            die_roll: (num, low, high) => {
              let sum = 0;
              for (let i = 0; i < num; i++) {
                sum += Math.random() * (high - low) + low;
              }
              return sum / num;
            },
            die_roll_integer: (num, low, high) => {
              let sum = 0;
              for (let i = 0; i < num; i++) {
                sum += Math.floor(Math.random() * (high - low + 1)) + low;
              }
              return Math.floor(sum / num);
            },
            hermite_blend: (value) => value * value * (3 - 2 * value),
            lerp: (start, end, t) => start + (end - start) * t,
            lerprotate: (start, end, t) => {
              let diff = end - start;
              if (diff > Math.PI) diff -= 2 * Math.PI;
              if (diff < -Math.PI) diff += 2 * Math.PI;
              return start + diff * t;
            },
            ln: Math.log,
          };
          Object.freeze(math);

          const query = {
            noise: (x, y) => {
              return p5Instance.noise(x, y) * 2 - 1;
            }, // convert from 0-1 to -1 to 1
          };
          Object.freeze(query);

          const userFunction = new Function(
            "x",
            "y",
            "math",
            "query",
            `
            const variable = {
              originx: x,
              originz: y,
              worldx: x,
              worldz: y,
            };
            const v = variable;
            const q = query;
            
            // Execute user's custom code
            ${userInput}
            
            return 0;
        `
          );

          // Loop through every pixel based on worldSize
          const pixelArray = [];

          for (let y = 0; y < worldSize; y++) {
            for (let x = 0; x < worldSize; x++) {
              // Call the user function with x and y coordinates
              const colorResult = userFunction(x, y, math, query);

              // If the result is an RGB object, add it to the array
              if (colorResult && typeof colorResult === "object") {
                pixelArray.push({ r: colorResult.r ?? 0, g: colorResult.g ?? 0, b: colorResult.b ?? 0 });
              } else if (typeof colorResult === "number") {
                const clampedColorResult = math.clamp(colorResult, 0, 1);
                // Treat as grayscale value
                pixelArray.push({ r: clampedColorResult, g: clampedColorResult, b: clampedColorResult });
              }
            }
          }

          result = { text: "", pixelArray: normalizePixels(pixelArray) };

          // Restore original APIs
          window.alert = originalAlert;
          window.console = originalConsole;

          window.parent.postMessage(result, "*");
        } catch (error) {
          // Restore original APIs even in case of error
          window.alert = originalAlert;
          window.console = originalConsole;
          window.parent.postMessage({ text: `Error: ${error.message}`, pixelArray: [] }, "*");
        }
      });
    </script>
  </body>
</html>
